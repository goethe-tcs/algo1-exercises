% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo121}
\blattname{Wochenplan: Traversierung, Binäre Suchbäume}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newboolean{programming}
\setboolean{programming}{false}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\section*{Vorbereitung}
Lies CLRS Kapitel 12 ohne 12.4 und schau das Video der Woche.

\section*{Dienstag}
\begin{aufgabe}[Binärbaumeigenschaften]\label{tue-first}\mbox{}
	\begin{enumerate}
		\item (\warmup) Welche der Bäume sind binäre Suchbäume?
		\item (\warmup) Wo in einem Baum befinden sich die Elemente mit dem kleinsten und größten Schlüssel?
		\item (\warmup) Gib die Reihenfolge, in der die Knoten traversiert werden für Präorder, Inorder und Postorder für Baum b) an.
		\item Verleich die Heap-Eigenschaft und die Suchbaum-Eigenschaft.
		\item Schreibe Pseudocode für eine iterative Variante der Knotentraversierung in Inorder.
		\item (\hard) Beweise oder widerlege.
		Wenn Knoten $v$ zwei Kinder hat, dann hat das Element mit dem nächstgrößeren Schlüssel kein linkes Kind und das Element mit dem nächstkleineren Schlüssel kein rechtes Kind.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Blätter und Höhe]
	Sei $T$ ein Binärbaum mit $n$ Knoten und Wurzel $w$.
	\begin{enumerate}
		\item Entwirf einen rekursiven Algorithmus, der für Eingabe $w$ die Anzahl der Blätter in $T$ ausgibt.
		Schreibe deine Lösung in Pseudocode auf.
		\item Entwirf einen rekursiven Algorithmus, der für Eingabe $w$ die Höhe von $T$ ausgibt.
		Schreibe deine Lösung in Pseudocode auf.
		\ifthenelse{\boolean{programming}}{
		\item Implementiere deine Lösung in einer Sprache deiner Wahl.
		}{}
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Mehr Rekursionen auf Bäumen]
	Sei $T$ ein Binärbaum.
	Jeder Knoten $x$ von $T$ hat die Variablen $x.parent$, $x.left$ und $x.right$, welche respektiv auf den Elterknoten sowie linkes und rechtes Kind von $x$ verweisen.
	Wenn der Knoten keine Kinder (z.B. Blätter) oder keinen Elternknoten (Wurzel $root$) hat wird der jeweilige Wert auf $null$ gesetzt.
	Des weiteren hat jeder Knoten $x$ eine $x.size$ Variable, die auf einen Integer gesetzt werden kann.
	Betrachte den folgenden Algorithmus.
	\begin{algorithmic}
		\State {\texttt{ZERO}($x$)}
		\If{$x\neq null$}
			\State{\texttt{ZERO}($x.left$)}
			\State{\texttt{ZERO}($x.right$)}
		\EndIf
	\end{algorithmic}
		
	\begin{enumerate}
		\item Analysiere die Laufzeit des Algorithmus für den Aufruf mit Knoten $x$, der Wuzel eines (Teil-)Baums mit $n$ Knoten ist.
		\item Sei $T(x)$ der Teilbaum mit Wurzel $x$ und sei $|T(x)|$ die Anzahl an Knoten in $T(x)$.
		Entwirf einen Algorithmus \texttt{InitSize($x$)}, der gegeben einen Knoten $x$ für allen Knoten $y$ in $T(x)$ die Variable $y.size$ auf $|T(y)|$ setzt.
		Schreibe den Algorithmus in Pseudocode auf und analysiere die Laufzeit im Verhältnis zu $|T(x)|$.
		\item Wir bezeichnen eine Kante von Elternknoten $u$ zu Kind $v$, ($u$,$v$), als $rot$ genau dann wenn $|T(x)| \geq 2\cdot|T(y)|$.
		Entwirf einen rekursiven Algorithmus \texttt{RedEdge($x$)}, der die Anzahl an als rot klassifizierten Kanten des Teilbaums $T(x)$ berechnet.
		Schreibe den Algorithmus in Pseudocode auf und analysiere die Laufzeit im Verhältnis zu $|T(x)|$.
		\item Gib eine obere und untere Schranke, in Groß-O Notation, für die Anzahl an roten Kanten, in einem Pfad von der Wurzel zu einem Blatt, an.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Traversierung von binären Suchbäumen]
	\begin{enumerate}
		\item Entwirf einen Algorithmus, der für einen binären Suchbaum $T$ mit Schlüssel für alle Knoten ermittelt, ob $T$ die Suchbaumeigenschaft erfüllt.
		\item Entwirf einen Algorithmus, der für einen binären Suchbaum $T$ einen \textit{umgedrehten binären Suchbaum} $T^R$ aufbaut.
		$T^R$ soll ein binärer Suchbaum sein mit den selben Schlüsseln wie in $T$.
		Für jeden Knoten $v$ mit Schlüssel $s$ in $T^R$ gilt, dass alle Knoten im linken Teilbaum von $v$ Schlüssel haben, die größer gleich $s$ sind, und alle Knoten im linken Teilbaum von $v$ Schlüssel haben, die kleiner gleich $s$ sind.
		\item (\hard) Entwirf einen Algorithmus, der gegeben zwei binäre Suchbäume $T_1$ und $T_2$ einen einzigen binären Suchbaum mit den Elementen aus $T_1$ und $T_2$ macht.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Ausbalancierte binäre Suchbäume]
	Sei $A$ ein sortiertes Feld mit $n = 2^{h+1}-1$ paarweise unterschiedlichen Nummern.
	Gib eine Sequenz an Feldindizes, sodass das Einfügen der korrespondierenden Nummern aus $A$ in einen binären Suchbaum in der Konstruktion eines vollständigen Binärbaums resultiert.
\end{aufgabe}

\begin{aufgabe}[Preorder Traversierung]
	Entwirf einen rekursiven Algorithmus für preorder Traversierung.
	\ifthenelse{\boolean{programming}}{Implementiere den Algorithmus in einer Sprache deiner Wahl.}{}
\end{aufgabe}

\begin{aufgabe}[Noch mehr rekursion auf Bäumen]
	Sei $T$ ein Binärbaum.
	Jeder Knoten $x$ von $T$ hat die Variablen $x.parent$, $x.left$ und $x.right$, welche respektiv auf den Elterknoten sowie linkes und rechtes Kind von $x$ verweisen.
	Wenn der Knoten keine Kinder (z.B. Blätter) oder keinen Elternknoten (Wurzel $root$) hat wird der jeweilige Wert auf $null$ gesetzt.
	Des weiteren hat jeder Knoten $x$ eine $x.label$ Variable, die auf einen einzelnen Buchstaben ($character$) speichert.
	Betrachte den folgenden Algorithmus und Binärbaum.
	\begin{algorithmic}
		\State {\texttt{PrintTree}($x$)}
		\If{$x\neq null$}
			\Output{$x.label$}
			\If{$x.left \neq null$}
				\State{\texttt{PrintTree}($x.left$)}
			\EndIf
			\If{$x.right \neq null$}
				\State{\texttt{PrintTree}($x.right$)}
			\EndIf
		\EndIf
	\end{algorithmic}
		
	\begin{enumerate}
		\item Wenn wir \texttt{PrintTree} mit der Wurzel aufrufen wird \glqq CROOL\grqq{} in unsere Konsole geprintet.
		Wie muss \texttt{PrintTree} modifiziert werden, sodass wir stattdessen \glqq COLOR\grqq{} bekommen.
		\item Entwirf einen rekursiven Algorithmus \texttt{Internal}($x$), der die Anzahl an Knoten in dem in $x$ verwurzelten Teilbaum $T(x)$ berechnet.
		Schreibe deinen Algorithmus in Pseudocode und analysiere die Laufzeit als Funktion 
		\item Wir sagen, das ein Baum einen \textit{R-Pfad} hat, wenn es einen Pfad von der Wurzel zu einem Blatt gibt, sodass alle Knoten $v$ im Pfad $v.label = 'R'$ haben.
		Entwirf einen rekursiven Algorithmus \texttt{RPfad($x$)}, der für Knoten $x$ ermittelt, ob es einen R-Pfad in $T(x)$ gibt.
		Schreibe den Algorithmus in Pseudocode auf und analysiere die Laufzeit im Verhältnis zu $|T(x)|$.
	\end{enumerate}
\end{aufgabe}

\end{document}
