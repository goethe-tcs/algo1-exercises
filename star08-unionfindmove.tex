% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo121}
\blattname{\emoji{star}-Aufgabe: Union Find Move}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
  Entwickle eine möglichst effiziente Implementierung der folgenden abstrakten Datenstruktur:
  Verwalte eine Familie von disjunkten Mengen, anfangs die einelementigen Mengen
  \[ \{0\},\{1\}, \ldots,\{n-1\}\,,\]
  unter den folgenden Operationen:
  \begin{description}
   \item[0 (\enquote{query})]
      Die \emph{query} Operation nimmt zwei Argumente $s$ und $t$, und ermittelt, ob $s$ und $t$ zur selben Menge gehören.
      Das heißt, wenn $s\in S$ and $t\in T$, dann gibt die Operation \texttt{1} aus falls $S=T$ und \texttt{0} wenn $S\neq T$.
    \item[1 (\enquote{union})]
    Die \emph{union} Operation nimmt zwei Argumente $s$ und $t$, und erzeugt die Vereinigung der beiden Mengen, die $s$ und $t$ enthalten.
    Das heißt, wenn $s\in S$ und $t\in T$ mit $S\neq T$, dann sollen $S$ und $T$ aus der Familie entfernt und durch die Menge $S\cup T$ ersetzt werden.
      (Wenn $S=T$, dann passiert nichts.)
    \item[2 (\enquote{move})]
      Die \emph{move} Operation nimmt zwei Argumente $s$ und $t$, und verschiebt das Element $s$ in die Menge, die $t$ enthält.
      Das heißt, wenn $s\in S$ und $t\in T$ mit $S\neq T$, dann sollen $S$ und $T$ aus der Familie entfernt werden und stattdessen die Mengen $S-\{s\}$ (falls diese nichtleer ist)  und $T\cup\{s\}$ zur Familie hinzugefügt werden.
      (Wenn $S= T$, dann passiert nichts.)
  \end{description}
  Diese Operationen erhalten die Invariante, dass die Mengen in der Familie disjunkt sind.
  
  \begin{enumerate}
    \item\label{describe} Beschreibe deine Datenstruktur und analysiere sie
    \item\label{implement} Implementiere und teste deine Datenstruktur gemäß der Anforderungen in Abschnitt~\ref{implementierung}.
  \end{enumerate}

  \textbf{Hinweise zur Abgabe.}
  Mindestens~\ref{describe} muss bearbeitet werden.
  Die Union-Find Datenstrukturen aus der Vorlesung reichen hier nicht aus, sondern müssen modifiziert werden, daher ist eine klare und anschauliche Beschreibung der Idee besonders wichtig. Kleine Bildchen wären nützlich, um den Zustand deiner Datenstruktur zu verstehen.
  Erwartet werden ansonsten wie üblich die grobe Idee, Pseudocode oder echter Code, Korrektheitsbeweis, Laufzeitanalyse.

  \appendix
  \section{Implementierung}\label{implementierung}
  Für die Implementierung soll folgendes Ein- und Ausgabeverhalten unterstützt werden.
  \subsection*{Eingabe}
  
  Die Eingabe startet mit zwei natürlichen Zahlen $n$ und $m$ in der ersten Zeile.
  Die Zahl $n$ ist die Anzahl an einelementigen Mengen zu Beginn.
  Dann folgen $m$ Zeilen der Form
  \enquote{\texttt{0} $s$ $t$} (für \emph{query}) oder \enquote{\texttt{1} $s$ $t$} (für \emph{union}) oder \enquote{\texttt{2} $s$ $t$} (für \emph{move}).
  Du kannst $0\leq s< n$ und $0\leq t< n$ annehmen.

  \subsection*{Ausgabe}
  
  Für jede \emph{query} Operation wird wie oben beschrieben eine Zeile mit \texttt{1} oder \texttt{0} ausgegeben.
  
  \subsection*{Beispiel}
  \begin{tabular}{ll}
  \texttt{example.in}& Zustand der Datenstruktur nach der Operation\\
    \texttt{4 9}   & $\{0\}, \{1\}, \{2\},\{3\}$\\
    \texttt{0 0 1} \\
    \texttt{1 0 1} & $\{0, 1\}, \{2\},\{3\}$ \\
    \texttt{0 0 1} &\\
    \texttt{1 1 2} & $\{0, 1, 2\},\{3\}$ \\
    \texttt{0 1 2} &\\
    \texttt{0 0 3} &\\
    \texttt{2 2 3}   & $\{0, 1\}, \{2,3\}$ \\
    \texttt{0 0 1} &\\
    \texttt{0 1 2} &
  \end{tabular}

  \noindent
  \begin{verbatim}
example.ans
0
1
1
0
1
0
  \end{verbatim}

  \subsection*{Mehr Tests}
  Hier gibt es größere Tests:\\
  \small\url{https://tcs.uni-frankfurt.de/teaching/summer21/algo1/unionfindmove-tests.zip}
\end{document}
