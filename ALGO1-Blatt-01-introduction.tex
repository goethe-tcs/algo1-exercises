% LTeX: language=de-DE
\documentclass{uebung_cs}
\usepackage{algo123}
\uebung{1}{}{}
\blattname{Einführung und Peaks (Woche 1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \renewtheorem{aufgabe}{A}[uebungnr]

\begin{document}
\legende{}

% Aufgaben~\ref{tue-first} bis~\ref{tue-last} werden \textbf{Dienstag} in Präsenz bearbeitet.
% Asynchron lesen Sie dann CLRS Kapitel~1 und schauen das erste Video an.
% Aufgaben~\ref{thu-first} bis~\ref{thu-last} werden \textbf{Donnerstag} in Präsenz bearbeitet.
% Die \emoji{star}-Aufgabe 2D-Hügel finden Sie in Moodle.

\section*{Dienstag}

\begin{aufgabe}[Schleifen \bestehen]\label{tue-first}
	Schau Dir das Codefragment an (entweder in Python oder in Java/C/C++).
	Was geben die Funktionen \texttt{loop1}, \texttt{loop2}, \texttt{loop3}, \texttt{loop4} jeweils zurück, wenn die Eingabe $n=4$ ist? Was bei Eingabe $n=10$? Was bei Eingabe $n=1000$? Was geben sie als Funktion von $n$ zurück?

	\begin{tabular}{ccr}
		\hspace{1cm}
\begin{lstlisting}[language=Python]
# Python

def loop1(n):
	x = 0
	for i in range(n):
		for j in range(n):
			x += 1
	return x

def loop2(n):
	x = 0
	for i in range(n):
		x += 1
	for j in range(n):
		x += 1
	return x
	
def loop3(n):
	x = 0
	for i in range(n):
		if (i == n-1):
			for j in range(n):
				x += 1
	return x

def loop4(n):
	x = 0
	for i in range(n):
		for j in range(i,n):
			x += 1
	return x
\end{lstlisting}
&\mbox{}\hspace{2cm}\mbox{}&
\begin{lstlisting}[language=Java]
/* Java/C/C++ */

int loop1(int n) {
	int x = 0;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) x++;
	}
	return x;
}

int loop2(int n) {
	int x = 0;
	for(int i = 0; i < n; i++) x++;
	for(int j = 0; j < n; j++) x++;
	return x;
}

int loop3(int n) {
	int x = 0;
	for(int i = 0; i < n; i++) {
		if (i == n-1)
			for(int j = 0; j < n; j++)
				x++;
	}
	return x;
}

int loop4(int n) {
	int x = 0;
	for(int i = 0; i < n; i++) {
		for(int j = i; j < n; j++) x++;
	}
	return x;
}
\end{lstlisting}
\end{tabular}
\end{aufgabe}

\newpage
\begin{aufgabe}[Rekursion und Iteration \bestehen]
	Eine Funktion ist \emph{rekursiv}, wenn sie sich selbst aufruft. Zum Beispiel:

	\begin{tabular}{lcl}
\begin{lstlisting}[language=Python]
# Python

def f(A, n):
	if (n == 0):
		return 0
	else:
		return f(A, n-1) + A[n-1]
\end{lstlisting}
&\mbox{}\hspace{2cm}\mbox{}&
	\begin{lstlisting}[language=Java]
/* Java/C/C++ */

int f(int[] A, int n) {
	if(n == 0) return 0;
	else return f(A, n-1) + A[n-1];
}\end{lstlisting}
	\end{tabular}
	\begin{enumerate}
		\item Was liefert \texttt{f(A,n)} zurück, wenn \texttt{A} ein Array ist, das \texttt{n} Zahlen enthält?
		\item Kann man \texttt{f(A,n)} auch \emph{iterativ} machen? Das heißt, kann man den Code so umschreiben, dass die Funktion sich nicht selbst aufruft, aber dasselbe Ergebnis liefert? Wie?
	\end{enumerate}
\end{aufgabe}


\begin{aufgabe}[Coronatests]
	Das Gesundheitsamt schickt euch eine Gruppe von 128 Personen mit der gesicherten Information, dass genau eine davon mit SARS-CoV-2 infiziert ist. Aber wer ist es? Euer Testzentrum hat nur eine PCR-Maschine zur Verfügung und ein Durchlauf auf einer Probe dauert eine Stunde. Ihr wollt das Ergebnis aber so schnell wie möglich wissen. Da das PCR-Verfahren hochsensitiv ist, könnt ihr problemlos Abstriche von mehreren Personen zu einer Probe zusammenlegen, um zu testen, ob mindestens eine der gewählten Personen positiv ist.
	\begin{enumerate}
		\item\bestehen Wie findet man den positiven Fall in 7 Stunden?
		\item\bestehen Wie viele Stunden braucht ihr, um $n$ Personen zu testen anstatt $128$?
		\item\mittel Unerwarteterweise finden sich in einem Nebenraum deines Testzentrums plötzlich $k-1$ verstaubte, aber funktionsbereite PCR-Maschinen, ihr könnt also $k$ Proben pro Stunde testen. Wie viele Stunden braucht ihr in dieser Situation, um den positiven Fall zu finden?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Zombieduelle \spass]
	Ihr habt eine Armee von $n$ hirnlosen Zombies und wollt den stärksten und den schwächsten finden. Ihr könnt zwei Zombies in einen Käfig sperren und ein Stück Fleisch zwischen sie werfen, um umgehend herauszufinden, wer von den beiden der Stärkere ist. Da ihr die massenhafte Fleischproduktion aus ethischen Gründen ablehnt, wollt ihr die Zahl der Duelle so klein wie möglich halten.
	\begin{enumerate}
		\item Wie findet man den stärksten Zombie mit höchstens $n-1$ Duellen?
		\item (schwer) Wie findet man sowohl den stärksten als auch den schwächsten Zombie mit höchstens $3n/2$ Duellen?
		\item (sehr schwer) Wie findet man sowohl den stärksten als auch den zweitstärksten Zombie mit höchstens $n+\log_2 n$ Duellen?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Ameisen auf dem Stock \spass, sehr schwer]\label{tue-last}
	Auf einem 100 cm langen Stock befinden sich 100 Ameisen.
	Zu Beginn wird jede Ameise auf dem Stock positioniert und entweder nach links oder nach rechts ausgerichtet.
	Dann fangen alle Ameisen gleichzeitig an, sich zu bewegen.
	Jede Ameise bewegt sich exakt 1 cm pro Sekunde. Wenn eine Ameise auf eine ihr entgegen kommende Ameise trifft, drehen sich beide Ameisen sofort um und laufen in die andere Richtung weiter.
	Wenn eine Ameise eines der beiden Stockenden erreicht, fällt sie runter.
	Wie lange dauert es maximal (über alle möglichen Startkonfigurationen), bis alle Ameisen vom Stock gefallen sind?
\end{aufgabe}

\section*{Vorbereitung}
Lies CLRS Kapitel 1 und schau dir das erste Video an.

\section*{Donnerstag}
\begin{aufgabe}[Hügel]\label{thu-first}
	Sei $A = [2, 1, 3, 7, 3, 11, 1, 5, 7, 10]$.
	\begin{enumerate}
		\item \bestehen (einfach) Finde alle Hügel von $A$.
		\item \bestehen (einfach) Welche Hügel werden von den beiden Linearzeitalgorithmen jeweils ausgegeben?
		\item \bestehen Gib die Sequenz von rekursiven Aufrufen an, die der rekursive Algorithmus produziert. Nimm hierfür zunächst an, dass der Algorithmus immer die linke Hälfte des Arrays wählt, wenn beide Richtungen möglich wären. Gib anschließend alle möglichen Sequenzen von rekursiven Aufrufen an, die der Algorithmus machen kann, wenn er jedes Mal eine zufällige gültige Richtung wählt.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Täler \bestehen]
	Überlegt euch ein \emph{Talproblem} als Gegenstück zum Hügelproblem.
	Stellt eine präzise Definition des Talproblems auf.
\end{aufgabe}

\begin{aufgabe}[Algorithmen und Anwendungen \bestehen] Diskutiert:
	\begin{enumerate}
		\item Kann ein algorithmisches Problem von verschiedenen Algorithmen gelöst werden?
		\item Kann ein und derselbe Algorithmus mehr als ein algorithmisches Problem lösen?
		\item Kann ein abstrakter Datentyp von verschiedenen Datenstrukturen implementiert werden?
		\item Gib ein Problem in der echten Welt an, für das man zwingend die optimale Lösung braucht. Gib ebenso ein Problem an, wo eine approximative Lösung ausreicht.
	\end{enumerate}	
\end{aufgabe}

\begin{aufgabe}[\bestehen]
	Gegeben sind Algorithmus A mit Laufzeit $100n^2$ und Algorithmus B mit Laufzeit~$2^n$.
	Was ist der kleinste positive Wert von $n\in\mathbb{N}$, sodass Algorithmus A auf demselben Rechner schneller läuft als Algorithmus B?
\end{aufgabe}

\begin{aufgabe}[Hügeleigenschaften \mittel]
	Sei $A$ ein Array der Länge $n\ge 1$.
	\begin{enumerate}
		\item Beweise, dass $A$ immer mindestens einen Hügel hat.
		\item Was ist die maximale Anzahl an Hügeln, die $A$ haben kann?
		\item Angenommen wir ändern die Definition von Hügel so, dass $A[i]$ ein Hügel ist, wenn $A[i]$ echt größer als seine Nachbarn ist. Welchen Effekt hat die Änderung auf die beiden Eigenschaften?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Noch mehr Hügel \mittel]\label{thu-last}\mbox{}
	\begin{enumerate}
		\item Was ist die schlimmste Eingabe für jeden der drei Hügelalgorithmen?
		\item Schreib den rekursiven Algorithmus so um, dass er iterativ wird. Schreib hierfür den Pseudocode.
		\item Beweise, dass der rekursive Algorithmus immer einen Hügel findet. \emph{Hinweis:} Definiere eine nützliche Invariante, die für jeden rekursiven Aufruf gilt, und gib einen Beweis per Induktion.
		\item Implementiere (in einer echten Programmiersprache deiner Wahl) die beiden Linearzeitalgorithmen um Hügel zu finden.
		\item Implementiere auch den rekursiven Algorithmus, um Hügel zu finden (achte darauf, dass dein Programm immer nur auf die Positionen $0$ bis $n-1$ des Arrays zugreifen darf).
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[2D-Hügel, \schriftlich]
	Sei $M$ eine $n\times n$ Matrix (ein zweidimensionales Array).
	Ein Eintrag $M[i][j]$ ist ein Hügel, wenn er nicht kleiner ist als seine Nachbarn im N,O,S,W ist (das heißt $M[i][j]\ge M[i][j-1]$, $M[i][j]\ge M[i+1][j]$, $M[i][j]\ge M[i][j+1]$, und $M[i][j]\ge M[i-1][j]$; die Randfälle sind analog zu den Hügeln im 1D-Fall zu verstehen).
	Wir wollen nun einen effizienten Algorithmus entwerfen, der einen Hügel in $M$ findet.
	\begin{enumerate}
		\item \bestehen Gib einen einfachen Algorithmus an, der $O(n^2)$ Zeit braucht.
		\item \mittel Gib einen Algorithmus an, der $O(n \log n)$ Zeit braucht. Begründe, wieso die Laufzeitschranke gilt. \emph{Hinweis:} Beginne, indem du die maximale Zahl in der mittleren Spalte findest, und benutze dies, um das Problem rekursiv zu lösen.
		\item \note Gib einen Algorithmus an, der $O(n)$ Zeit braucht. Begründe, wieso die Laufzeitschranke gilt. \emph{Hinweis:} Konstruiere einen rekursiven Algorithmus, der $M$ in 4 Quadranten aufteilt.
	\end{enumerate}
\end{aufgabe}
\end{document}
