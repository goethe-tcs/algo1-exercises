% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo121}
\blattname{Wochenplan: Suchen und Sortieren}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

\section*{Vorbereitung}
Lies CLRS Kapitel 2 und schau dir die Videos der Woche an.

\section*{Dienstag}

\begin{aufgabe}[Von Hand laufen lassen und Eigenschaften]\label{tue-first}\mbox{}
	\begin{enumerate}
		\item (\warmup) Beschreibe den Ablauf von insertion sort, wenn die Eingabe ein Feld $A=[31,41,59,26,41,58]$ ist.
		\item (\warmup) Verändere den Pseudocode für insertion sort, um das Eingabefeld monoton fallend anstatt monoton wachsend zu ordnen.	
		\item Analysiere \emph{die Laufzeit im mittleren Fall} von linearer Suche.
		\item (\warmup) Beschreibe den Ablauf von merge sort auf dem Feld $A=[3,41,52,26,38,57,9,49]$.
		\item Überzeuge dich, dass insertion sort auch rekursiv wie folgt formuliert werden kann: um $A[0..n-1]$ zu sortieren, sortieren wir $A[0..n-2]$ rekursiv und fügen dann $A[n-1]$ in das sortierte Feld $A[0..n-2]$ ein. Stelle die Rekursionsgleichung für die Laufzeit dieses Algorithmus auf und löse sie.
		\item Ein Freund schlägt vor, dass du binäre Suche nutzen solltest, um den Einfügeschritt von insertion sort schneller zu machen. Funktioniert das, und welchen Effekt hat es auf die Laufzeit des Algorithmus?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Duplikate und nahe Nachbarn]
	Sei $A[0..n-1]$ ein Feld von ganzen Zahlen.
	\begin{enumerate}
		\item (\warmup) Ein \emph{Duplikat} in $A$ ist ein Paar $(i,j)$ von unterschiedlichen Indizes mit $A[i]=A[j]$. Gib einen Algorithmus an, der in Zeit $O(n^2)$ ein Duplikat in $A$ findet.
		\item Gib einen Algorithmus an, der in $A$ ein Duplikat in Zeit $O(n\log n)$ findet. \emph{Hinweis:} Nutze merge sort.
		\item Ein \emph{nächster Nachbar} in $A$ ist ein Paar $(i,j)$ mit $i\ne j$, sodass der Abstand $|A[i]-A[j]|$ minimal ist unter allen Paaren von Einträgen. Gib einen Algorithmus an, der in $A$ einen nächsten Nachbarn in Zeit $O(n\log n)$ findet.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Korrektheit von Merge Sort]
	Beweise, dass Merge Sort alle gegebenen Felder korrekt sortiert. Hierbei darfst du annehmen, dass die Verflechtungsoperation \textsc{Merge} auf sortierten Feldern korrekt arbeitet.
	\emph{Hinweis: benutze vollständige Induktion.}
\end{aufgabe}

\section*{Donnerstag}

\begin{aufgabe}[2-Summe und 3-Summe]
	Sei $A[0..n-1]$ ein Feld von ganzen Zahlen (positive und negative Zahlen sind erlaubt).
	Das Feld $A$ hat eine \emph{2-Summe}, wenn es zwei Einträge $i$ und~$j$ gibt mit $A[i]+A[j]=0$.
	Analog hat $A$ eine \emph{3-Summe}, wenn es drei Einträge $i$, $j$, und $k$ gibt, sodass $A[i]+A[j]+A[k]=0$.
	\begin{enumerate}
		\item (\warmup) Gib einen einfachen Algorithmus an, der in Zeit $O(n^2)$ feststellt, ob $A$ eine 2-Summe hat.
		\item Gib einen Algorithmus an, der in Zeit $O(n\log n)$ feststellt, ob $A$ eine 2-Summe hat. \emph{Hinweis: binäre Suche.}
		\item (\warmup) Gib einen Algorithmus an, der in Zeit $O(n^3)$ feststellt, ob $A$ eine 3-Summe hat.
		\item Gib einen Algorithmus an, der in Zeit $O(n^2\log n)$ feststellt, ob $A$ eine 3-Summe hat. \emph{Hinweis: binäre Suche.}
		\item (\veryhard) Gib einen Algorithmus an, der in Zeit $O(n^2)$ feststellt, ob $A$ eine 3-Summe hat.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Auswahl, Partition, und Quick Sort]
Sei $A[0..n-1]$ ein Feld von unterschiedlichen ganzen Zahlen.
Der Eintrag von \emph{Rang $k$} in $A$ ist die $k$t kleinste Zahl unter den Zahlen in $A$.
Der \emph{Median} von $A$ ist die Zahl von Rang $\lfloor(n-1)/2\rfloor$.
\begin{enumerate}
	\item Gib einen Algorithmus mit Laufzeit $O(n\log n)$ an, der $A$ und $k$ als Eingabe nimmt und die Zahl in $A$ ausgibt, die Rang $k$ hat.
\end{enumerate}
Eine \emph{Partition} von $A$ ist eine Aufteilung in Felder $A_\text{low}$ und $A_\text{high}$, sodass $A_\text{low}$ alle Zahlen von $A$ enthält, die kleiner oder gleich dem Median von $A$ sind, und $A_\text{high}$ enthält alle Zahlen von $A$, die größer sind als der Median von $A$.
Es gibt einen Linearzeitalgorithmus, der den Median eines Feldes findet; diesen Algorithmus darfst du im Folgenden einfach annehmen.
\begin{enumerate}[resume]
	\item Gib einen Algorithmus an, der eine Partition von $A$ in Zeit $O(n)$ ausrechnet.
	\item (\hard) Gib einen Algorithmus an, der $A$ in Zeit $O(n\log n)$ sortiert, indem er rekursiv partitioniert.
	\item (\veryhard) Gib einen Algorithmus mit Laufzeit $O(n)$ an, der $A$ und $k$ als Eingabe nimmt und die Zahl in $A$ ausgibt, die Rang $k$ hat.
\end{enumerate}
\end{aufgabe}


\begin{aufgabe}[$k$-Merge Sort]
	Professorin M.\ Erge stellt ihren neuen Algorithmus, 3-Merge Sort, vor.
	3-Merge Sort funktioniert genau wie das uns bekannte Merge Sort, nur wird rekursiv in drei Teile anstatt zwei aufgeteilt, die daraufhin sortiert und wieder verflochten werden.
	Löse die folgenden Teilaufgaben.
	\begin{enumerate}
		\item Zeige, dass sich drei sortierte Felder in asymptotischer Linearzeit verflechten lassen.
		\item Führe eine Laufzeitanalyse für 3-Merge Sort durch. Stelle hierzu die Rekursionsgleichung für die Laufzeit $T(n)$ auf und löse diese.
		\item (\hard) Verallgemeinere den Algorithmus und die Analyse von 3-Merge Sort zu $k$-Merge Sort für $k>3$.\\
		Hat Prof.\ M.\ Erge den Durchbruch geschafft?
		Stellt $k$-Merge Sort eine Verbesserung gegenüber dem klassischen 2-Merge Sort dar?
	\end{enumerate}
\end{aufgabe}

\end{document}
