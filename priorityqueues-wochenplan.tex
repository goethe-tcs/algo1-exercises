% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo121}
\blattname{Wochenplan: Prioritätswarteschlangen, Heaps}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newboolean{programming}
\setboolean{programming}{false}

\tikzset{every tree node/.style={minimum width=20pt,draw,circle},
blank/.style={draw=none},
edge from parent/.style=
{draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
level distance=1.5cm}

\begin{document}
\section*{Vorbereitung}
Lies CLRS Kapitel 6, sowie Appendix B.5 und schau das Video der Woche.

\section*{Dienstag}
\begin{aufgabe}[Heap-Eigenschaften]\label{tue-first}
	Löse die folgenden Teilaufgaben.
	\begin{enumerate}
		\item (\warmup) Welche der folgenden Bäume erfüllen die Heap-Eigenschaft?
		\begin{center}
			\begin{figure}[h]
				\begin{subfigure}[b]{0.3\textwidth}
					\hspace*{\fill}
					\scalebox{0.5}
					{
						\begin{tikzpicture}[sibling distance=20pt]
							\Tree
							[.16 
								[.13
									[.7
										\edge[]; {4}
										\edge[blank]; \node[blank]{};
									] 
									5
								]
								[.11
									9
									1
								]
							]
						\end{tikzpicture}
					}
					\hspace*{\fill}
					\caption{}
				\end{subfigure}
				\begin{subfigure}[b]{0.3\textwidth}
					\hspace*{\fill}
					\scalebox{0.5}
					{
						\begin{tikzpicture}[sibling distance=20pt]
							\Tree
							[.20 
								[.18 
									[.16
										13
										4
									]
									[.15
										7
										19
									]
								]
								[.14
									[.11
										\edge[]; {2}
										\edge[blank]; \node[blank]{};
									]
									10
								]
							]
						\end{tikzpicture}
					}
					\hspace*{\fill}
					\caption{}
				\end{subfigure}
				\begin{subfigure}[b]{0.3\textwidth}
					\hspace*{\fill}
					\scalebox{0.5}
					{
						\begin{tikzpicture}[sibling distance=20pt]
							\Tree
							[.9 
								[.8 
									[.6
										3
										2
									]
									\edge[blank]; \node[blank]{};
								]
								[.7
									[.5
										\edge[]; {1}
										\edge[blank]; \node[blank]{};
									]
									4
								]
							]
						\end{tikzpicture}
					}
					\hspace*{\fill}
					\caption{}
				\end{subfigure}
			\end{figure}
		\end{center}
				\item (\warmup) Welche der durch folgende Felder repräsentierten Bäume erfüllen die Heap-Eigenschaft?
		Index 0 wird nicht benutzt und ist deshalb mit -- markiert.
		\begin{center}
			$A = [\text{--},9,7,8,3,4]$\hspace*{3em}$B = [\text{--},12,4,7,1,2,10]$\hspace*{3em}$C = [\text{--},5,7,8,3]$
		\end{center}
		\item (\warmup) Sei $S = 4,8,11,5,21,\star,2,\star$ eine Sequenz von Operationen, wobei eine Zahl für das Einfügen dieser Zahl in den Heap steht und $\star$ für eine \texttt{ExtractMax} Operation.
		Wie sieht der Heap $H$ nach jeder einzelnen Operation aus, wenn $H$ anfangs leer ist?
		\item Erfüllt ein sortiertes Feld die Heap-Eigenschaft?
		\item Wo befindet sich in einem (Max-)Heap das kleinste Element?
		\item Zeige, dass \texttt{Insert}, \texttt{ExtractMax} und \texttt{IncreaseKey} die Heap-Eigenschaft aufrechterhalten.
    \item (\hard) Angenommen wir erhalten $k$ sortierte Felder mit \textbf{insgesamt} $n$ Elementen als Eingabe.
		Zeige, wie sich alle Felder in Zeit $O(n\log k)$ zu einem einzelnen sortierten Feld der Länge~$n$ verflechten lassen.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Priogruppen-Politik, \warmup]
	Die Kakistokratische Partei will deine Hilfe um ihre neue \enquote{Frischluft}-Politik umzusetzen.
	Entwirf ein Bürgerregister, das alle Bürger:innen und ihre Gehälter so speichert, dass man die Person mit dem geringsten Einkommen möglichst schnell finden und ausbürgern kann.

	Das System soll die folgenden Operationen unterstützen:
	\begin{itemize}
		\item \texttt{Insert(c,i)} fügt eine Person mit der Sozialversicherungsnummer $c$ und dem jährlichen Gehalt $i$ ein.
		\item \texttt{DeportLowestIncome()} Gibt die Person mit dem niedrigsten Einkommen aus und entfernt sie aus dem System.
	\end{itemize}
	Entwirf eine möglichst effiziente Datenstruktur, die das System implementiert.
\end{aufgabe}

\begin{aufgabe}[Operationen für Prioritätswarteschlangen]
	Wir wollen nun die Menge an zur Verfügung stehenden Operationen für Prioritätswarteschlangen vergrößern.
	Wir interessieren uns hierbei für die folgenden Operationen:
	\begin{itemize}
		\item \texttt{RemoveLargest($m$)} entfernt das $m$t-größte Element der Prioritätswarteschlange.
		\item \texttt{Delete($x$)} entfernt Element $x$ aus der Prioritätswarteschlange.
		\item \texttt{Fusion($x,y$)} entfernt Elemente $x$ und $y$ aus der Prioritätswarteschlange und fügt ein neues Element~$z$ mit Schlüssel $x$.key + $y$.key ein.
		\item \texttt{FindLarger($k$)} gibt all jene Elemente der Prioritätswarteschlange aus, deren Schlüssel mindestens so groß wie $k$ ist.
		\item \texttt{ExtractMin()} gibt das Element der Prioritätswarteschlange mit dem kleinsten Schlüssel aus und entfernt es.
	\end{itemize}
	Wir wollen diese Operationen effizient implementieren, ohne dass sich die Komplexität der Standardoperationen \texttt{Insert}, \texttt{IncreaseKey}, \texttt{Max} und \texttt{ExtractMax} ändert.

	Sei $n$ die Anzahl der Elemente in der Prioritätswarteschlange.
	Löse die folgenden Teilaufgaben:
	\begin{enumerate}
		\item Erkläre wie sich \texttt{RemoveLargest($m$)} mit Zeitbedarf $O(m\log n)$ implementieren lässt.
		\item Erkläre wie sich \texttt{Delete($x$)} und \texttt{Fusion($x,y$)} mit Zeitbedarf $O(\log n)$ implementieren lässt.
		\item (\hard) Erkläre wie sich \texttt{FindLarger($k$)} mit Zeitbedarf $O(m)$ implementieren lässt, wobei $m$ die Anzahl der Elemente mit Schlüssel $\geq k$ ist.
		\item (\hard) Erkläre wie sich \texttt{ExtractMin()} mit Zeitbedarf $O(\log n)$ implementieren lässt.
	\end{enumerate}
\end{aufgabe}

\section*{Donnerstag}
\begin{aufgabe}[Satellitendaten]
	Sei $A[0..n-1]$ ein als Feld gespeicherter Heap.
	Jedes Element~$x$ in dem Heap wird durch einen Index $i$ repräsentiert und hat einen Schlüssel, der als $A[i]$ gespeichert ist.
	Es ist oftmals nützlich, zusätzliche Informationen (=Satellitendaten) zu speichern, die mit einem Element assoziiert sind.
	Modifiziere die Datenstruktur so, dass eine neue Operation \texttt{SatelliteData$(i)$} in Zeit~$O(1)$ die Satellitendaten des Elements mit Index $i$ zurückliefert. Hierbei dürfen sich die asymptotischen Laufzeiten der Standardoperationen des Heaps nicht verändern.
\end{aufgabe}

\begin{aufgabe}[Eigenschaften von Heaps]
	Sei $T = (V,E)$ ein vollständiger Binärbaum von Höhe~$h$.
	Löse die folgenden Teilaufgaben.
	\begin{enumerate}
		\item Zeige, dass für die Anzahl an Knoten $|V| = 2^{h+1} - 1$ gilt.\\
		\textit{Hinweis: Begründe, dass $|V| = 1 + 2 + 4 + \hdots + 2^h$ gilt und betrachte diesen Wert als Binärzahl.}
		\item Zeige: Für die Summe $S$ mit $S = n / 4 \cdot 1 + n / 8 \cdot 2 + n / 16 \cdot 3 + n / 32 \cdot 4 + \hdots$ gilt $S = \Theta(n)$.\\
		\textit{Hinweis: Berechne $S - S/2$}
	\end{enumerate}
\end{aufgabe}

\ifthenelse{\boolean{programming}}{
\begin{aufgabe}[Implementierung von Heaps]
	Wir interessieren uns dafür eine Prioritätswarteschlange mittels eines Heap auf einem Feld zu implementieren.
	\begin{enumerate}
		\item Implementiere die zuvor genannte Datenstruktur mitsamt \texttt{Insert} und \texttt{ExtractMax} Operationen in einer Programmiersprache deiner Wahl.
	\end{enumerate}
\end{aufgabe}
}{}

\begin{aufgabe}[Summen]
	Sei $A[0..n-1]$ ein Feld von ganzen Zahlen.
	Wir interessieren uns für die folgenden Operationen:
	\begin{itemize}
		\item \texttt{Sum($i,j$)} gibt $A[i] + A[i+1] + \hdots + A[j]$ aus.
		\item \texttt{Change($i,x$)} setzt $A[i]$ auf den Wert $x$.
	\end{itemize}
	Löse die folgenden Teilaufgaben:
	\begin{enumerate}
		\item (\warmup) Entwirf eine Datenstruktur, die \texttt{Sum} mit $O(1)$ Zeit und $O(n^2)$ Platz unterstützt.
		\item (\hard) Entwirf eine Datenstruktur, die \texttt{Sum} mit $O(1)$ Zeit und $O(n)$ Platz unterstützt.
		\item (\veryhard) Entwirf eine Datenstruktur, die \texttt{Sum} und \texttt{Change} beide mit $O(\log n)$ Zeit und $O(n)$ Platz unterstützt.
	\end{enumerate}
\end{aufgabe}

\end{document}
